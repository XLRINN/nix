#!/usr/bin/env bash

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Emojis
ROCKET="🚀"
GEAR="⚙️"
DISK="💾"
COMPUTER="💻"
CHECK="✅"
WARNING="⚠️"
ERROR="❌"
INFO="ℹ️"
QUESTION="❓"
PARTY="🎉"

# Determine the operating system
export OS=$(uname)

# Primary network interface
if [[ "$OS" != "Darwin" ]]; then
  export PRIMARY_IFACE=$(ip -o -4 route show to default | awk '{print $5}')
  echo -e "${GREEN}${INFO} Found primary network interface: $PRIMARY_IFACE${NC}"
fi

# Custom print function
_print() {
  echo -e "$1"
}

# Custom prompt function
_prompt() {
  local message="$1"
  local variable="$2"

  echo -n -e "$message"
  read -r $variable
}


# Prompt for Age private key used to decrypt SOPS files at activation.
# Prefer env AGE_PRIVATE_KEY or a readable file path.
prompt_age_key() {
  if [[ -n "${AGE_PRIVATE_KEY:-}" ]]; then
    umask 0077
    printf "%s\n" "$AGE_PRIVATE_KEY" > /tmp/age_private_key.txt
    chmod 600 /tmp/age_private_key.txt 2>/dev/null || true
    _print "${CYAN}${INFO} Captured Age private key from environment.${NC}"
    return
  fi
  local path
  _print "${CYAN}${INFO} Optional: provide your Age private key or a path to it (e.g., /root/keys.txt).${NC}"
  _print "${CYAN}You can paste the key (starts with AGE-SECRET-KEY-1...) or enter a readable file path. Press Enter to skip.${NC}"
  _prompt "Age key or file path: " path
  if [[ -z "$path" ]]; then
    _print "${YELLOW}${INFO} Skipping Age key staging.${NC}"
    return
  fi
  if [[ "$path" == AGE-SECRET-KEY-* ]]; then
    umask 0077
    printf "%s\n" "$path" > /tmp/age_private_key.txt
    chmod 600 /tmp/age_private_key.txt 2>/dev/null || true
    _print "${GREEN}${CHECK} Age key captured for install.${NC}"
  elif [[ -r "$path" ]]; then
    umask 0077
    cp "$path" /tmp/age_private_key.txt
    chmod 600 /tmp/age_private_key.txt 2>/dev/null || true
    _print "${GREEN}${CHECK} Age key staged for install.${NC}"
  else
    _print "${YELLOW}${INFO} Skipping Age key staging.${NC}"
  fi
}

# Set default values
export USERNAME="david"
export GIT_EMAIL="xlrin.morgan@gmail.com"
export GIT_NAME="david"

# Clear screen and show ASCII art
clear
echo
echo "    ███╗   ██╗██╗   ██╗██╗  ██╗"
echo "    ████╗  ██║╚██╗ ██╔╝╚██╗██╔╝"
echo "    ██╔██╗ ██║ ╚████╔╝  ╚███╔╝ "
echo "    ██║╚██╗██║  ╚██╔╝   ██╔██╗ "
echo "    ██║ ╚████║   ██║   ██╔╝ ██╗"
echo "    ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝"
echo "            --XLRINN--"
echo
echo "═══════════════════════════════════════════════════════════"
echo

# Ask for Age private key (for SOPS)
prompt_age_key

# Enhanced drive selection (supports NONINTERACTIVE mode)
select_drive() {
  if [[ "${NONINTERACTIVE:-}" == "1" ]]; then
    local selected_drive="/dev/${BOOT_DISK:-nvme0n1}"
    _print "${GREEN}NONINTERACTIVE: selecting ${selected_drive}${NC}"
    for disk_file in ./modules/nixos/disk-config.nix ./modules/nixos/disk-config-btrfs.nix; do
      if [[ -f "$disk_file" ]]; then
        sed -i "s|device = \"/dev/sda\";|device = \"$selected_drive\";|g" "$disk_file"
      fi
    done
    export BOOT_DISK=$(basename "$selected_drive")
    return
  fi
  _print "\n${YELLOW}=== Available Drives ===${NC}"
  _print "Scanning for available drives..."
  
  # Get list of drives (excluding loop devices and partitions)
  drives=($(lsblk -d -n -o NAME,SIZE,MODEL | grep -E '^(sd[a-z]|nvme[0-9]+n[0-9]+|hd[a-z])' | awk '{print $1}'))
  
  # Try to identify the live USB drive to exclude it
  live_usb=""
  if [ -f /proc/cmdline ]; then
    cmdline=$(cat /proc/cmdline)
    if echo "$cmdline" | grep -q "boot=live"; then
      # This is a live USB, try to identify it
      live_usb=$(lsblk -d -n -o NAME,MOUNTPOINT | grep "/run/archiso/bootmnt\|/run/archiso/airootfs\|/run/archiso/iso" | head -1 | awk '{print $1}')
    fi
  fi
  
  if [ ${#drives[@]} -eq 0 ]; then
    _print "${RED}No suitable drives found!${NC}"
    exit 1
  fi
  
  # Warn about live USB if detected
  if [ -n "$live_usb" ]; then
    _print "\n${YELLOW}${WARNING}  Live USB detected: /dev/$live_usb${NC}"
    _print "${YELLOW}Make sure you don't select this drive for installation!${NC}"
  fi
  
  _print "\n${GREEN}Available drives:${NC}"
  for i in "${!drives[@]}"; do
    drive_info=$(lsblk -d -n -o NAME,SIZE,MODEL /dev/${drives[$i]} | head -1)
    drive_size=$(echo "$drive_info" | awk '{print $2}')
    drive_model=$(echo "$drive_info" | awk '{for(i=3;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ *$//')
    _print "  ${YELLOW}[$((i+1))]${NC} /dev/${drives[$i]} - ${GREEN}Size: $drive_size${NC} - ${CYAN}Model: $drive_model${NC}"
  done

  if [ ${#drives[@]} -eq 1 ]; then
    selected_drive="/dev/${drives[0]}"
    _print "\n${GREEN}Only one drive detected; auto-selecting: $selected_drive${NC}"
    for disk_file in ./modules/nixos/disk-config.nix ./modules/nixos/disk-config-btrfs.nix; do
      if [[ -f "$disk_file" ]]; then
        sed -i "s|device = \"/dev/sda\";|device = \"$selected_drive\";|g" "$disk_file"
        grep 'device = ' "$disk_file" || true
      fi
    done
    export BOOT_DISK=$(basename "$selected_drive")
    return
  fi

  while true; do
    _prompt "${YELLOW}${QUESTION} Select drive number (1-${#drives[@]}): ${NC}" choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#drives[@]}" ]; then
      selected_drive="/dev/${drives[$((choice-1))]}"
      _print "\n${GREEN}Selected drive: $selected_drive${NC}"
      for disk_file in ./modules/nixos/disk-config.nix ./modules/nixos/disk-config-btrfs.nix; do
        if [[ -f "$disk_file" ]]; then
          sed -i "s|device = \"/dev/sda\";|device = \"$selected_drive\";|g" "$disk_file"
          grep 'device = ' "$disk_file" || true
        fi
      done
      _print "${GREEN}${CHECK} Drive configuration updated!${NC}"
      _print "${GREEN}${CHECK} NixOS will be installed on: $selected_drive${NC}"
      _print "${YELLOW}Proceeding with installation...${NC}"
      export BOOT_DISK=$(basename $selected_drive)
      break
    else
      _print "${RED}Invalid selection. Please enter a number between 1 and ${#drives[@]}.${NC}"
    fi
  done
}

# Remove swap definitions when the user opts out.
disable_swap_partition() {
  local files=(
    "./modules/nixos/disk-config.nix"
    "./modules/nixos/disk-config-btrfs.nix"
  )
  if command -v perl >/dev/null 2>&1; then
    for file in "${files[@]}"; do
      if [[ -f "$file" ]]; then
        perl -0pi -e 's/\n(\s*)swap = \{\n(?:.*?\n)\1\};\n/\n/s' "$file"
      fi
    done
    if [[ -f ./hosts/nixos/default.nix ]]; then
      perl -0pi -e 's/\n\s*swapDevices = lib\.mkForce \[\{\n(?:.*?\n)*?\s*\}\];\n//s' ./hosts/nixos/default.nix
    fi
  elif command -v python3 >/dev/null 2>&1; then
    python3 <<'PY'
from pathlib import Path
import re

files = [
    Path("modules/nixos/disk-config.nix"),
    Path("modules/nixos/disk-config-btrfs.nix"),
]
pattern = re.compile(r"\n(\s*)swap = \{\n(?:.*?\n)\1\};\n", re.S)
for path in files:
    if path.exists():
        text = path.read_text()
        path.write_text(pattern.sub("\n", text))

host = Path("hosts/nixos/default.nix")
if host.exists():
    host.write_text(re.sub(r"\n\s*swapDevices = lib\\.mkForce \[\{\n(?:.*?\n)*?\s*\}\];\n", "\n", host.read_text(), flags=re.S))
PY
  else
    if ! command -v awk >/dev/null 2>&1; then
      echo -e "${RED}Unable to disable swap automatically: awk is required.${NC}"
      exit 1
    fi
    local file tmp
    for file in "${files[@]}"; do
      if [[ -f "$file" ]]; then
        tmp=$(mktemp)
        if awk '
function flush() {
  for (i = 1; i <= buf_len; ++i) print buf[i]
  buf_len = 0
}
{
  line = $0
  if (skip) {
    if (close_pattern != "" && line ~ close_pattern) {
      skip = 0
      close_pattern = ""
    }
    next
  }
  if (line ~ /^[[:space:]]*swap = [{]$/) {
    if (buf_len > 0) {
      buf_len -= 1
    }
    if (match(line, /^([[:space:]]*).*/, m)) {
      close_pattern = "^" m[1] "[}];[[:space:]]*$"
    } else {
      close_pattern = "^[[:space:]]*[}];[[:space:]]*$"
    }
    skip = 1
    next
  }
  if (line ~ /^[[:space:]]*$/) {
    buf[++buf_len] = line
    next
  }
  flush()
  print line
}
END {
  flush()
}
        ' "$file" > "$tmp"; then
          mv "$tmp" "$file"
        else
          rm -f "$tmp"
          echo -e "${RED}Failed to strip swap definition from $file.${NC}"
          exit 1
        fi
      fi
    done

    if [[ -f ./hosts/nixos/default.nix ]]; then
      tmp=$(mktemp)
      if awk '
function flush() {
  for (i = 1; i <= buf_len; ++i) print buf[i]
  buf_len = 0
}
{
  line = $0
  if (skip) {
    if (line ~ /^[[:space:]]*[}][]];[[:space:]]*$/) {
      skip = 0
    }
    next
  }
  if (line ~ /^[[:space:]]*swapDevices = lib[.]mkForce [[][{]$/) {
    if (buf_len > 0) {
      buf_len -= 1
    }
    skip = 1
    next
  }
  if (line ~ /^[[:space:]]*$/) {
    buf[++buf_len] = line
    next
  }
  flush()
  print line
}
END {
  flush()
}
      ' ./hosts/nixos/default.nix > "$tmp"; then
        mv "$tmp" ./hosts/nixos/default.nix
      else
        rm -f "$tmp"
        echo -e "${RED}Failed to strip swapDevices override from ./hosts/nixos/default.nix.${NC}"
        exit 1
      fi
    fi
  fi
  echo -e "${CYAN}${INFO} Swap configuration removed; system will be installed without swap.${NC}"
}

# Detect total system RAM (GiB, ceiling) and prompt for desired swap size.
configure_swap() {
  if [[ "$OS" == "Darwin" ]]; then return; fi
  if ! grep -q 'swap = {' ./modules/nixos/disk-config.nix 2>/dev/null; then
    return
  fi
  if [[ -r /proc/meminfo ]]; then
    local mem_kb total_gib
    mem_kb=$(grep -i '^MemTotal:' /proc/meminfo | awk '{print $2}')
    if [[ -n "$mem_kb" ]]; then
      total_gib=$(( (mem_kb + 1024*1024 - 1) / (1024*1024) ))
      TOTAL_RAM_GIB=$total_gib
    fi
  fi
  TOTAL_RAM_GIB=${TOTAL_RAM_GIB:-8}

  local input_swap=""
  if [[ "${NONINTERACTIVE:-}" == "1" ]]; then
    input_swap="${SWAP_SIZE:-}"
  else
    echo -e "${YELLOW}${QUESTION} Detected RAM: ${TOTAL_RAM_GIB}G. Enter swap size (e.g. 8G, 32G). Leave blank for no swap:${NC}"
    read -r input_swap
  fi

  if [[ -z "$input_swap" || "$input_swap" =~ ^0[Gg]?$ ]]; then
    disable_swap_partition
    return
  fi

  SWAP_SIZE="$input_swap"
  if [[ "$SWAP_SIZE" =~ ^[0-9]+$ ]]; then
    SWAP_SIZE="${SWAP_SIZE}G"
  fi
  if [[ ! "$SWAP_SIZE" =~ ^[0-9]+G$ ]]; then
    echo -e "${RED}Invalid swap size format: $SWAP_SIZE (expected e.g. 16 or 16G). Aborting.${NC}"; exit 1
  fi

  sed -i "/swap/,/root/ s/size = \"[^\"]*\";/size = \"$SWAP_SIZE\";/" ./modules/nixos/disk-config.nix
  local swap_gib=${SWAP_SIZE%G}
  if (( swap_gib < TOTAL_RAM_GIB )); then
    echo -e "${YELLOW}${WARNING} Swap (${swap_gib}G) is smaller than RAM (${TOTAL_RAM_GIB}G); hibernation may fail.${NC}"
  else
    echo -e "${GREEN}${CHECK} Swap size set to $SWAP_SIZE (>= RAM ${TOTAL_RAM_GIB}G).${NC}"
  fi
}

# Prompt for static IP (optional). Leave blank for DHCP.
prompt_ip() {
  if [[ "$OS" == "Darwin" ]]; then return; fi
  if [[ "${NONINTERACTIVE:-}" == "1" ]]; then
    IP_ADDR=${IP_ADDR:-}
    return
  fi
  while true; do
    _prompt "${YELLOW}${QUESTION} Static IPv4 (CIDR) or blank for DHCP: ${NC}" IP_ADDR
    if [[ -z "$IP_ADDR" ]]; then
      _print "${GREEN}${INFO} Using DHCP.${NC}"
      break
    fi
    if [[ "$IP_ADDR" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]]; then
      # Basic octet range check
      ok=1
      IFS='./' read -r o1 o2 o3 o4 cidr <<<"$IP_ADDR"
      for o in $o1 $o2 $o3 $o4; do
        if (( o < 0 || o > 255 )); then ok=0; break; fi
      done
      if (( cidr < 0 || cidr > 32 )); then ok=0; fi
      if (( ok )); then
        _print "${GREEN}${CHECK} Static IP set: $IP_ADDR${NC}"
        break
      fi
    fi
    _print "${RED}Invalid format. Use e.g. 192.168.1.50/24 or leave blank.${NC}"
  done
  export IP_ADDR
}
# prompt_bws_token() {
#   local token pass confirm
#   token="${BWS_ACCESS_TOKEN:-}"

#   if [[ -z "$token" && "${NONINTERACTIVE:-}" != "1" ]]; then
#     _print "${CYAN}${INFO} Optional: provide a Bitwarden Secrets Manager access token to bootstrap secrets.${NC}"
#     _print "${CYAN}Press Enter to skip if you prefer to configure secrets later.${NC}"
#     _prompt "BWS access token: " token
#   fi

#   if [[ -z "$token" ]]; then
#     rm -f /tmp/bws_access_token /tmp/bws_token_passphrase
#     return
#   fi

#   umask 0077
#   printf "%s" "$token" > /tmp/bws_access_token
#   chmod 600 /tmp/bws_access_token 2>/dev/null || true

#   pass="${BWS_TOKEN_PASSPHRASE:-}"
#   if [[ -z "$pass" && "${NONINTERACTIVE:-}" != "1" ]]; then
#     _print "${CYAN}${INFO} Optional: encrypt the token into secrets/bws.token.age using a passphrase.${NC}"
#     _print "${CYAN}Leave blank to place the token in ~/.secrets/bws.env instead.${NC}"
#     read -r -s -p "Passphrase (optional): " pass; echo
#     if [[ -n "$pass" ]]; then
#       read -r -s -p "Confirm passphrase: " confirm; echo
#       if [[ "$pass" != "$confirm" ]]; then
#         _print "${YELLOW}Passphrases did not match; skipping encryption (token will be stored in ~/.secrets/bws.env).${NC}"
#         pass=""
#       fi
#     fi
#   fi

#   if [[ -n "$pass" ]]; then
#     printf "%s" "$pass" > /tmp/bws_token_passphrase
#     chmod 600 /tmp/bws_token_passphrase 2>/dev/null || true
#   else
#     rm -f /tmp/bws_token_passphrase
#   fi
# }

# Set hostname and find primary disk if this is NixOS
if [[ "$OS" != "Darwin" ]]; then
  if [[ "${NONINTERACTIVE:-}" == "1" ]]; then
    HOST_NAME=${HOST_NAME:-tyr}
    _print "${GREEN}NONINTERACTIVE: Hostname set to: $HOST_NAME${NC}"
  else
    while true; do
      _prompt "${YELLOW}${QUESTION} Hostname: ${NC}" HOST_NAME
      if [[ -z "$HOST_NAME" ]]; then
        _print "${RED}Hostname cannot be empty. Please enter a hostname.${NC}"
        continue
      fi
      # Optional: basic validation; allow a-z0-9- and dots, start/end with alnum
      if [[ ! "$HOST_NAME" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*$ ]]; then
        _print "${RED}${WARNING} Hostname contains unusual characters.${NC}"
        # Ask to re-enter
        continue
      fi
      _print "${GREEN}${CHECK} Hostname set to: $HOST_NAME${NC}"
      break
    done
  fi

  prompt_ip
  select_drive
    configure_swap
fi

# Auto-detect Framework laptop and set nixos-hardware profile
configure_hardware_profile() {
  if [[ "$OS" == "Darwin" ]]; then return; fi
  local profile=""

  if command -v dmidecode >/dev/null 2>&1; then
    local vendor product
    vendor=$(dmidecode -s system-manufacturer 2>/dev/null || true)
    product=$(dmidecode -s system-product-name 2>/dev/null || true)
    if echo "$vendor" | grep -qi "framework" || echo "$product" | grep -qi "framework"; then
      # detect CPU vendor
      if command -v lscpu >/dev/null 2>&1 && lscpu | grep -qi amd; then
        profile="framework/13-inch/amd/7040"
      else
        profile="framework/13-inch/intel"
      fi
    fi
  fi

  if [[ -n "$profile" ]]; then
    _print "${GREEN}${INFO} Detected Framework laptop; applying nixos-hardware profile: ${profile}${NC}"
    # Write a literal path into hardware-profile.nix to avoid referencing config during module eval
    cat > ./hosts/nixos/hardware-profile.nix <<EOF
{ inputs, lib, ... }:
let
  path = "${profile}";
in
{
  imports = lib.optionals (path != null) [ (inputs.nixos-hardware + "/" + path) ];
}
EOF
  else
    _print "${CYAN}${INFO} No vendor-specific hardware profile applied.${NC}"
  fi
}

# # Collect Bitwarden token information (optional) before continuing
# prompt_bws_token


# Run hardware configuration before applying token replacements
configure_hardware_profile

# Show installation starting
echo
_print "${CYAN}${INFO} Starting installation...${NC}"

# Safely replace tokens, escaping sed-sensitive characters
safe_substitute() {
  local target="$1"
  local placeholder="$2"
  local value="$3"
  local escaped
  # If the value is empty, skip substitution to avoid erasing tokens
  if [[ -z "$value" ]]; then
    return 0
  fi
  escaped=$(printf '%s' "$value" | sed -e 's/[\\/&|]/\\&/g')
  if [[ "$OS" == "Darwin" ]]; then
    LC_ALL=C LANG=C sed -i '' -e "s|$placeholder|$escaped|g" "$target"
  else
    sed -i -e "s|$placeholder|$escaped|g" "$target"
  fi
}

# Function to replace tokens in each file
replace_tokens() {
  local file="$1"
  if [[ $(basename "$1") != "apply" ]]; then
    if [[ "$OS" == "Darwin" ]]; then
      safe_substitute "$file" "%USER%" "$USERNAME"
      safe_substitute "$file" "%EMAIL%" "$GIT_EMAIL"
      safe_substitute "$file" "%NAME%" "$GIT_NAME"
    else
      safe_substitute "$file" "%USER%" "$USERNAME"
      safe_substitute "$file" "%EMAIL%" "$GIT_EMAIL"
      safe_substitute "$file" "%NAME%" "$GIT_NAME"
      safe_substitute "$file" "%INTERFACE%" "$PRIMARY_IFACE"
      safe_substitute "$file" "%DISK%" "$BOOT_DISK"
      safe_substitute "$file" "%HOST%" "$HOST_NAME"
      if [[ -n "$IP_ADDR" ]]; then
        safe_substitute "$file" "%IP%" "$IP_ADDR"
      else
        safe_substitute "$file" "%IP%" "dhcp"
      fi
    fi
  fi
}

  # Apply configuration
_print "${BLUE}${GEAR} Applying configuration...${NC}"
export -f safe_substitute
export -f replace_tokens
# Export token values so they are visible to the subshell spawned by find -exec
export HOST_NAME USERNAME GIT_EMAIL GIT_NAME PRIMARY_IFACE BOOT_DISK IP_ADDR
# Correctly pass the filename as $1 into the subshell
find . -type f -exec bash -c 'replace_tokens "$1"' bash {} \;

  echo "$USERNAME" > /tmp/username.txt
  echo -n "$HOST_NAME" > /tmp/hostname.txt
  # Persist git identity for installer phase
  echo -n "$GIT_NAME" > /tmp/git_name.txt
  echo -n "$GIT_EMAIL" > /tmp/git_email.txt
  _print "${GREEN}${PARTY} Ready!${NC}"

## Bitwarden legacy discovery removed in favor of sopswarden.
# _print "${CYAN}${INFO} Using sopswarden for secrets. After first boot run:${NC}"
# _print "${YELLOW}  rbw login && rbw unlock${NC}"
# _print "${YELLOW}  sops-sync && sops-deploy${NC}"

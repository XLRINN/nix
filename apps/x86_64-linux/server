#!/usr/bin/env bash
set -eu

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Emojis
ROCKET="ðŸš€"
SERVER="ðŸ–¥ï¸"
DISK="ðŸ’¾"
NETWORK="ðŸŒ"
USER="ðŸ‘¤"
EMAIL="ðŸ“§"
HOSTNAME="ðŸ·ï¸"
SUCCESS="âœ…"
ERROR="âŒ"
WARNING="âš ï¸"
INFO="â„¹ï¸"

# Custom print function
_print() {
  echo -e "$1"
}

# Custom prompt function (commented out for testing)
# _prompt() {
#   local message="$1"
#   local variable="$2"
#   _print "$message"
#   read -r $variable
# }

check_installer() {
  if [ -e /etc/NIXOS ]; then
    _print "${GREEN}${SUCCESS} Running in the NixOS installer environment.${NC}"
  else
    _print "${RED}${ERROR} Not running in the NixOS installer environment.${NC}"
    exit 1
  fi
}

# Set defaults and get user input
get_user_input() {
  _print "${CYAN}${USER} Server Configuration${NC}"
  
  # Set defaults for faster testing
  export USERNAME="david"
  export GIT_EMAIL="xlrin.morgan@gmail.com"
  export GIT_NAME="david"
  export NETWORK_CONFIG="dhcp"
  export HOST_NAME="loki"
  
  # Auto-detect disk
  local auto_detected_disk=""
  for disk in vda sda nvme0n1; do
    if [ -b "/dev/$disk" ]; then
      auto_detected_disk="$disk"
      break
    fi
  done
  
  if [ -z "$auto_detected_disk" ]; then
    auto_detected_disk=$(lsblk -nd --output NAME | grep -v loop | grep -v sr0 | head -1)
  fi
  
  export BOOT_DISK="$auto_detected_disk"
  
  _print "${GREEN}${SUCCESS} Using defaults for faster testing:${NC}"
  _print "${GREEN}Hostname: $HOST_NAME${NC}"
  _print "${GREEN}Network: $NETWORK_CONFIG${NC}"
  _print "${GREEN}Boot disk: $BOOT_DISK${NC}"
  
  # Commented out for faster testing
  # # Ask for hostname
  # _print "${YELLOW}Enter hostname for the server: ${NC}"
  # read -r HOST_NAME
  # 
  # while [[ -z "$HOST_NAME" ]]; do
  #   _print "${RED}${ERROR} Hostname cannot be empty!${NC}"
  #   _print "${YELLOW}Enter hostname for the server: ${NC}"
  #   read -r HOST_NAME
  # done
  # 
  # export HOST_NAME="$HOST_NAME"
  # 
  # # Ask for IP (DHCP if left blank)
  # _print "${YELLOW}Enter static IP (or press Enter for DHCP): ${NC}"
  # read -r STATIC_IP
  # 
  # if [[ -z "$STATIC_IP" ]]; then
  #   export NETWORK_CONFIG="dhcp"
  #   _print "${GREEN}${SUCCESS} Using DHCP${NC}"
  # else
  #   export NETWORK_CONFIG="static"
  #   export STATIC_IP="$STATIC_IP"
  #   # Assume /24 subnet and gateway
  #   export SUBNET_MASK="255.255.255.0"
  #   export GATEWAY="192.168.69.1"
  #   _print "${GREEN}${SUCCESS} Using /24 subnet (255.255.255.0)${NC}"
  #   _print "${GREEN}${SUCCESS} Gateway set to: 192.168.69.1${NC}"
  # fi
}

# Original user info function (commented out for testing)
# get_user_info() {
#   _print "${CYAN}${USER} User Setup${NC}"
#   _prompt "${YELLOW}Username (Enter for 'david'): ${NC}" USERNAME
#   
#   if [[ -z "$USERNAME" ]]; then
#     export USERNAME="david"
#   fi
#   
#   _print "${GREEN}${SUCCESS} Username set to: $USERNAME${NC}"
#   
#   export GIT_EMAIL="xlrin.morgan@gmail.com"
#   export GIT_NAME="$USERNAME"
#   _print "${GREEN}${SUCCESS} Name set to: $GIT_NAME${NC}"
# }

# Original hostname function (commented out for testing)
# get_hostname() {
#   _print "${CYAN}${HOSTNAME} Hostname${NC}"
#   _prompt "${YELLOW}Hostname: ${NC}" HOST_NAME
#   
#   while [[ -z "$HOST_NAME" ]]; do
#     _print "${RED}${ERROR} Hostname cannot be empty!${NC}"
#     _prompt "${YELLOW}Enter hostname for the server: ${NC}" HOST_NAME
#   done
#   
#   _print "${GREEN}${SUCCESS} Hostname set to: $HOST_NAME${NC}"
# }

# Original boot disk function (commented out for testing)
# get_boot_disk() {
#   _print "${CYAN}${DISK} Boot Disk${NC}"
#   
#   # Show available disks
#   _print "${BLUE}Available disks:${NC}"
#   disks=$(lsblk -nd --output NAME,SIZE,TYPE | grep -v loop | grep -v sr0)
#   echo "$disks"
#   
#   # Try to auto-detect the best disk
#   local auto_detected_disk=""
#   
#   # Check for common VM disk names first
#   for disk in vda sda nvme0n1; do
#     if [ -b "/dev/$disk" ]; then
#       auto_detected_disk="$disk"
#       break
#     fi
#   done
#   
#   # If no VM disk found, check for any available disk
#   if [ -z "$auto_detected_disk" ]; then
#     auto_detected_disk=$(lsblk -nd --output NAME | grep -v loop | grep -v sr0 | head -1)
#   fi
#   
#   if [ -n "$auto_detected_disk" ]; then
#     _print "${GREEN}Auto-detected disk: $auto_detected_disk${NC}"
#     _prompt "${YELLOW}Use auto-detected disk ($auto_detected_disk)? (Y/n): ${NC}" use_auto
#     case "$use_auto" in
#       [Nn] | [Nn][Oo] )
#         _prompt "${YELLOW}Enter boot disk name (e.g., vda, sda, nvme0n1): ${NC}" BOOT_DISK
#         ;;
#       *)
#         export BOOT_DISK="$auto_detected_disk"
#         _print "${GREEN}${SUCCESS} Using auto-detected disk: $BOOT_DISK${NC}"
#         ;;
#     esac
#   else
#     _print "${YELLOW}Could not auto-detect disk. Please select manually.${NC}"
#     _prompt "${YELLOW}Enter boot disk name (e.g., vda, sda, nvme0n1): ${NC}" BOOT_DISK
#   fi
#   
#   # Validate the selected disk exists
#   if [ ! -b "/dev/$BOOT_DISK" ]; then
#     _print "${RED}${ERROR} Selected disk /dev/$BOOT_DISK does not exist!${NC}"
#     _print "${YELLOW}Available disks:${NC}"
#     lsblk -nd --output NAME,SIZE,TYPE | grep -v loop | grep -v sr0
#     exit 1
#   fi
#   
#   _print "${GREEN}${SUCCESS} Using disk: $BOOT_DISK${NC}"
# }

# Original network config function (commented out for testing)
# get_network_config() {
#   _print "${CYAN}${NETWORK} Network${NC}"
#   _prompt "${YELLOW}Static IP (Enter for DHCP): ${NC}" STATIC_IP
#   
#   if [[ -z "$STATIC_IP" ]]; then
#     export NETWORK_CONFIG="dhcp"
#     _print "${GREEN}${SUCCESS} Using DHCP for automatic IP assignment${NC}"
#   else
#     export NETWORK_CONFIG="static"
#     _prompt "${YELLOW}Enter subnet mask (e.g., 255.255.255.0): ${NC}" SUBNET_MASK
#     export GATEWAY="192.168.69.1"
#     _print "${GREEN}${SUCCESS} Gateway set to: 192.168.69.1${NC}"
#   fi
# }

# Show configuration summary and confirm
confirm_configuration() {
  _print "${CYAN}${INFO} Configuration Summary${NC}"
  _print "${GREEN}Username: $USERNAME${NC}"
  _print "${GREEN}Email: $GIT_EMAIL${NC}"
  _print "${GREEN}Name: $GIT_NAME${NC}"
  _print "${GREEN}Hostname: $HOST_NAME${NC}"
  _print "${GREEN}Boot disk: $BOOT_DISK${NC}"
  _print "${GREEN}Network: $NETWORK_CONFIG${NC}"
  
  if [[ "$NETWORK_CONFIG" == "static" ]]; then
    _print "${GREEN}Static IP: $STATIC_IP${NC}"
    _print "${GREEN}Subnet Mask: $SUBNET_MASK${NC}"
    _print "${GREEN}Gateway: $GATEWAY${NC}"
  fi
  
  _print "${GREEN}${SUCCESS} Using defaults for faster testing!${NC}"
  
  # Commented out for faster testing
  # _print "${YELLOW}${WARNING} Continue with these settings? (Y/n): ${NC}"
  # read -r confirm
  # 
  # case "$confirm" in
  #   [Nn] | [Nn][Oo] )
  #     _print "${YELLOW}Let's adjust some settings...${NC}"
  #     get_additional_settings
  #     ;;
  #   *)
  #     _print "${GREEN}${SUCCESS} Confirmed!${NC}"
  #     ;;
  # esac
}

# Get additional settings if user wants to change defaults (commented out for faster testing)
# get_additional_settings() {
#   _print "${CYAN}${DISK} Boot Disk${NC}"
#   
#   # Show available disks
#   _print "${BLUE}Available disks:${NC}"
#   disks=$(lsblk -nd --output NAME,SIZE,TYPE | grep -v loop | grep -v sr0)
#   echo "$disks"
#   
#   _print "${YELLOW}Current disk: $BOOT_DISK${NC}"
#   _print "${YELLOW}Enter boot disk name (or press Enter to keep current): ${NC}"
#   read -r new_disk
#   
#   if [[ -n "$new_disk" ]]; then
#     export BOOT_DISK="$new_disk"
#     _print "${GREEN}${SUCCESS} Disk set to: $BOOT_DISK${NC}"
#   fi
#   
#   _print "${CYAN}${USER} Username${NC}"
#   _print "${YELLOW}Current username: $USERNAME${NC}"
#   _print "${YELLOW}Enter username (or press Enter to keep current): ${NC}"
#   read -r new_username
#   
#   if [[ -n "$new_username" ]]; then
#     export USERNAME="$new_username"
#     export GIT_NAME="$new_username"
#     _print "${GREEN}${SUCCESS} Username set to: $USERNAME${NC}"
#   fi
#   
#   # Ask for network settings if static IP is being used
#   if [[ "$NETWORK_CONFIG" == "static" ]]; then
#     _print "${CYAN}${NETWORK} Network Settings${NC}"
#     _print "${YELLOW}Current static IP: $STATIC_IP${NC}"
#     _print "${YELLOW}Enter static IP (or press Enter to keep current): ${NC}"
#     read -r new_ip
#     
#     if [[ -n "$new_ip" ]]; then
#       export STATIC_IP="$new_ip"
#       _print "${GREEN}${SUCCESS} IP set to: $STATIC_IP${NC}"
#     fi
#     
#     _print "${YELLOW}Current subnet mask: $SUBNET_MASK${NC}"
#     _print "${YELLOW}Enter subnet mask (or press Enter to keep current): ${NC}"
#     read -r new_subnet
#     
#     if [[ -n "$new_subnet" ]]; then
#       export SUBNET_MASK="$new_subnet"
#       _print "${GREEN}${SUCCESS} Subnet mask set to: $SUBNET_MASK${NC}"
#     fi
#     
#     _print "${YELLOW}Current gateway: $GATEWAY${NC}"
#     _print "${YELLOW}Enter gateway (or press Enter to keep current): ${NC}"
#     read -r new_gateway
#     
#     if [[ -n "$new_gateway" ]]; then
#       export GATEWAY="$new_gateway"
#       _print "${GREEN}${SUCCESS} Gateway set to: $GATEWAY${NC}"
#     fi
#   fi
#   
#   # Show final summary
#   confirm_configuration
# }

download_config() {
  _print "${CYAN}${SERVER} Downloading Configuration${NC}"
  curl -LJ0 https://github.com/xlrinn/nix/archive/server.zip -o nixos-config-main.zip
  unzip nixos-config-main.zip
  
  # Remove existing directory if it exists
  rm -rf nixos-config
  
  # Check what was extracted
  _print "${BLUE}Checking extracted contents...${NC}"
  ls -la
  
  # Look for the server directory
  if [ -d "nix-server" ]; then
    mv nix-server nixos-config
  else
    _print "${RED}${ERROR} Could not find nix-server directory in extracted contents${NC}"
    _print "${YELLOW}Available directories:${NC}"
    ls -d */
    exit 1
  fi
  
  cd nixos-config
  
  # Verify the directory structure
  _print "${BLUE}Verifying directory structure...${NC}"
  if [ ! -f "modules/server/disk-config.nix" ]; then
    _print "${RED}${ERROR} Server disk configuration not found!${NC}"
    _print "${YELLOW}Available files:${NC}"
    find . -name "*.nix" -type f | head -10
    exit 1
  fi
  
  _print "${GREEN}${SUCCESS} Configuration downloaded and verified!${NC}"
}

# Use the desktop's proven disk setup process
setup_disk_with_desktop_method() {
  _print "${CYAN}${DISK} Setting up disk using desktop method${NC}"
  
  # Set environment variables for the apply script
  export USERNAME="$USERNAME"
  export GIT_EMAIL="$GIT_EMAIL"
  export GIT_NAME="$GIT_NAME"
  export HOST_NAME="$HOST_NAME"
  export BOOT_DISK="$BOOT_DISK"
  export NETWORK_CONFIG="$NETWORK_CONFIG"
  
  # Use the desktop apply script for reliable disk setup
  _print "${BLUE}Running desktop apply script for disk configuration...${NC}"
  ./apps/x86_64-linux/apply --non-interactive
  
  # Verify the disk replacement worked
  if grep -q "%DISK%" modules/server/disk-config.nix; then
    _print "${RED}${ERROR} Disk replacement failed! %DISK% still found in disk-config.nix${NC}"
    _print "${YELLOW}Manual fix: sed -i 's/%DISK%/$BOOT_DISK/g' modules/server/disk-config.nix${NC}"
    exit 1
  fi
  
  _print "${GREEN}${SUCCESS} Disk configuration applied successfully!${NC}"
}



run_disko() {
  _print "${CYAN}${DISK} Setting up disk with Disko${NC}"
  
  # Use disko for disk setup
  _print "${YELLOW}Setting up disk with disko...${NC}"
  
  # Ensure we're in the correct directory and the file exists
  if [ ! -f "./modules/server/disk-config.nix" ]; then
    _print "${RED}${ERROR} Disk configuration file not found!${NC}"
    _print "${YELLOW}Current directory: $(pwd)${NC}"
    _print "${YELLOW}Looking for: ./modules/server/disk-config.nix${NC}"
    ls -la modules/server/ 2>/dev/null || _print "${YELLOW}modules/server/ directory not found${NC}"
    exit 1
  fi
  
  _print "${BLUE}${INFO} Using disk config: $(pwd)/modules/server/disk-config.nix${NC}"
  
  # Use the official Disko command pattern from documentation
  _print "${BLUE}${INFO} Running disko with official pattern...${NC}"
  
  # Run disko without confirmation for faster testing
  if sudo nix --experimental-features "nix-command flakes" run github:nix-community/disko/latest -- --mode zap_create_mount "./modules/server/disk-config.nix"; then
    _print "${GREEN}${SUCCESS} Disk setup complete!${NC}"
  else
    _print "${RED}${ERROR} Disko failed!${NC}"
    _print "${YELLOW}${WARNING} Check the error messages above${NC}"
    exit 1
  fi
}

setup_files() {
  _print "${CYAN}${SERVER} Setting up NixOS files${NC}"
  
  sudo mkdir -p /mnt/etc/nixos
  sudo cp -r * /mnt/etc/nixos
  cd /mnt/etc/nixos
  _print "${GREEN}${SUCCESS} Files copied to /mnt/etc/nixos${NC}"
}

# Function to troubleshoot installation issues (commented out for testing)
# troubleshoot_installation() {
#   _print "${CYAN}${INFO} Installation Troubleshooting${NC}"
#   
#   _print "${YELLOW}Checking system status...${NC}"
#   
#   # Check disk space
#   _print "${BLUE}Disk space:${NC}"
#   df -h /mnt
#   
#   # Check Nix daemon status
#   _print "${BLUE}Nix daemon status:${NC}"
#   sudo systemctl status nix-daemon --no-pager
#   
#   # Check network connectivity
#   _print "${BLUE}Network connectivity:${NC}"
#   ping -c 3 8.8.8.8
#   
#   # Check Nix store info
#   _print "${BLUE}Nix store info:${NC}"
#   nix-store --gc --print-dead
#   
#   _print "${YELLOW}If installation is stuck, try these commands manually:${NC}"
#   _print "${YELLOW}1. Restart Nix daemon: sudo systemctl restart nix-daemon${NC}"
#   _print "${YELLOW}2. Clear Nix store: sudo nix-collect-garbage -d${NC}"
#   _print "${YELLOW}3. Try installation with --no-channel-copy flag${NC}"
#   _print "${YELLOW}4. Check for network issues or firewall blocking downloads${NC}"
# }

# Function to retry installation with different options (commented out for testing)
# retry_installation() {
#   local FLAKE_TARGET="$1"
#   local retry_count=0
#   local max_retries=3
#   
#   while [ $retry_count -lt $max_retries ]; do
#     retry_count=$((retry_count + 1))
#     _print "${YELLOW}Retry attempt $retry_count of $max_retries${NC}"
#     
#     case $retry_count in
#       1)
#         _print "${BLUE}Trying with --no-channel-copy flag...${NC}"
#         if timeout 1800 sudo nixos-install --flake .#$FLAKE_TARGET --no-channel-copy --verbose; then
#           return 0
#         fi
#         ;;
#       2)
#         _print "${BLUE}Trying with --no-root-passwd flag...${NC}"
#         if timeout 1800 sudo nixos-install --flake .#$FLAKE_TARGET --no-root-passwd --verbose; then
#           return 0
#         fi
#         ;;
#       3)
#         _print "${BLUE}Trying with minimal flags...${NC}"
#         if timeout 1800 sudo nixos-install --flake .#$FLAKE_TARGET --no-channel-copy --no-root-passwd; then
#           return 0
#         fi
#         ;;
#     esac
#     
#     _print "${YELLOW}Retry $retry_count failed. Cleaning up and trying again...${NC}"
#     sudo nix-collect-garbage -d || true
#     sudo systemctl restart nix-daemon || true
#     sleep 5
#   done
#   
#   return 1
# }

install_nixos() {
  _print "${CYAN}${ROCKET} Installing NixOS${NC}"
  
  ARCH=$(uname -m)

  case "$ARCH" in
    x86_64)
      FLAKE_TARGET="x86_64-linux-server"
      ;;
    aarch64)
      FLAKE_TARGET="aarch64-linux-server"
      ;;
    *)
      _print "${RED}${ERROR} Unsupported architecture: $ARCH${NC}"
      exit 1
      ;;
  esac

  _print "${BLUE}Starting NixOS installation with target: $FLAKE_TARGET${NC}"
  
  # Pre-installation cleanup for low-resource systems
  _print "${YELLOW}Pre-installation cleanup for Hetzner...${NC}"
  sudo nix-collect-garbage -d || true
  sudo systemctl restart nix-daemon || true
  sleep 5
  
  # Conservative installation for Hetzner
  _print "${BLUE}Trying conservative installation for Hetzner...${NC}"
  if timeout 3600 sudo nixos-install --flake .#$FLAKE_TARGET --no-root-passwd --verbose; then
    _print "${GREEN}${SUCCESS} NixOS installation completed successfully${NC}"
    sudo chmod -R 775 /mnt/etc/nixos
    return 0
  else
    _print "${RED}${ERROR} Conservative installation failed, trying minimal...${NC}"
    
    # Ultra-minimal installation
    if timeout 3600 sudo nixos-install --flake .#$FLAKE_TARGET --no-channel-copy --no-root-passwd --verbose; then
      _print "${GREEN}${SUCCESS} NixOS installation completed successfully${NC}"
      sudo chmod -R 775 /mnt/etc/nixos
      return 0
    else
      _print "${RED}${ERROR} All installation strategies failed${NC}"
      _print "${YELLOW}Manual commands to try:${NC}"
      _print "${YELLOW}1. sudo nixos-install --flake .#$FLAKE_TARGET --no-root-passwd${NC}"
      _print "${YELLOW}2. sudo nixos-install --flake .#$FLAKE_TARGET --no-channel-copy --no-root-passwd${NC}"
      _print "${YELLOW}3. Check memory: free -h${NC}"
      _print "${YELLOW}4. Check disk space: df -h${NC}"
      return 1
    fi
  fi
}

prompt_reboot() {
  _print "${CYAN}${INFO} Installation Complete!${NC}"
  _print "${YELLOW}${WARNING} Installation completed successfully!${NC}"
  
  # Drop into terminal for manual password setup
  _print "${BLUE}${INFO} Dropping into terminal for manual password setup...${NC}"
  _print "${YELLOW}You can now set passwords manually:${NC}"
  _print "${YELLOW}1. Set root password: sudo chroot /mnt passwd root${NC}"
  _print "${YELLOW}2. Set user password: sudo chroot /mnt passwd david${NC}"
  _print "${YELLOW}3. Exit terminal when done: exit${NC}"
  
  # Start a new shell for manual password setup
  exec /bin/bash
}

cleanup() {
  _print "${CYAN}${INFO} Cleaning up temporary files${NC}"
  
  # Final garbage collection and cleanup
  _print "${YELLOW}Final cleanup and garbage collection...${NC}"
  sudo nix-collect-garbage -d || true
  sudo rm -rf /tmp/* || true
  sudo rm -rf /var/tmp/* || true
  rm -rf nixos-config-main.zip nixos-config-main nixos-config
  
  _print "${GREEN}${SUCCESS} Cleanup complete!${NC}"
}

# Main execution
_print "${PURPLE}${ROCKET} NixOS Server Installation${NC}"
_print "${BLUE}Installing CLI-only NixOS server${NC}"

check_installer
get_user_input
confirm_configuration
download_config
setup_disk_with_desktop_method
run_disko
setup_files
install_nixos
install_result=$?
cleanup
prompt_reboot 